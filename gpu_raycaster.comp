#version 430

precision highp float;

layout(local_size_x = 1, local_size_y = 1) in;

layout(rgba32f) uniform image2D img_output;

layout(location=2) uniform vec3 start_position;

layout(location=3) uniform vec2 camera_angles;

layout(location=4) uniform ivec2 render_dimension;

layout(location=5) uniform vec3 light_position;

layout(location=6) uniform mat3 rot_mat_camera;

float DistanceEstimator(vec3 p)
{
	vec3 v = vec3(mod(p.x, 1.0), p.y, mod(p.z, 1.0)) - vec3(0.5);
    //vec3 v = p;
	return length(v) - 0.25;
}

vec3 normalAt(vec3 p)
{
	float epsilon = 0.0001;
	vec3 xDir = vec3(epsilon, 0.0, 0.0);
	vec3 yDir = vec3(0.0, epsilon, 0.0);
	vec3 zDir = vec3(0.0, 0.0, epsilon);
	return normalize(vec3(DistanceEstimator(p+xDir)-DistanceEstimator(p-xDir),
		                  DistanceEstimator(p+yDir)-DistanceEstimator(p-yDir),
		                  DistanceEstimator(p+zDir)-DistanceEstimator(p-zDir)));
}

float castShadow(vec3 from)
{
	int MaximumRaySteps = 32;
	float MinimumDistance = 0.001;

	float totalDistance = 0.0;
	int steps;
	
	bool hit = false;
	vec3 p;
	float minDist = 100000;

	vec3 direction = normalize(light_position - from);

	for (steps=0; steps < MaximumRaySteps; steps++) 
	{
		p = from + totalDistance * direction;
		float distance = DistanceEstimator(p);

		minDist = min(distance, minDist);

		totalDistance += distance;
		if (abs(distance) < MinimumDistance) 
		{
			hit = true;
			break;
		}
	}

	if (hit)
	{
		return 0.2;
	}

	return 1.0-1.0/(1.0+minDist);
}

vec3 trace(vec3 from, vec3 direction) 
{
	int MaximumRaySteps = 128;
	float MinimumDistance = 0.001;

	float totalDistance = 0.0;
	int steps;
	
	bool hit = false;
	vec3 p;
	float minDist = 100000;
	for (steps=0; steps < MaximumRaySteps; steps++) 
	{
		p = from + totalDistance * direction;
		float distance = DistanceEstimator(p);

		minDist = min(distance, minDist);

		totalDistance += distance;
		if (abs(distance) < MinimumDistance) 
		{
			hit = true;
			break;
		}
	}

	if (hit)
	{
		vec3 normal = normalAt(p);
		float shadow = castShadow(p);
		float color = dot(normal, normalize(light_position-p))*shadow;
		return vec3(color);
	}

	float glow = 0.0;//1.0/(1.0+10.0*minDist);

	return vec3(glow);
}

void main() 
{  
	ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
	vec2 screen_offset = vec2(render_dimension.x/2, render_dimension.y/2);
	
	vec3 pixel = vec3(0.0);
	
	vec3 camera_origin = vec3(0.0, 0.0, -render_dimension.x);
	vec3 screen_coord = vec3(pixel_coord-screen_offset, 0.0);
	
	vec3 ray = normalize(screen_coord - camera_origin);

	ray = rot_mat_camera*ray;

	pixel = vec3(trace(start_position, ray));

	imageStore(img_output, pixel_coord, vec4(pixel, 1.0));
}