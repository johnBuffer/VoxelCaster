#version 430

precision highp float;

layout(local_size_x = 1, local_size_y = 1) in;

layout(rgba32f) uniform image2D img_output;

layout(location=2) uniform vec3 start_position;

layout(location=3) uniform vec2 camera_angles;

layout(location=4) uniform ivec2 render_dimension;

layout(location=5) uniform vec3 light_position;

layout(location=6) uniform mat3 rot_mat_camera;

float DistanceEstimator(vec3 p)
{
	vec3 v = vec3(mod(p.x, 1.0), p.y, mod(p.z, 1.0)) - vec3(0.5, 0.5, 0.5);
    //vec3 v = p;
	return min(length(v) - 0.25, p.y-0.25);
}

vec3 normalAt(vec3 p)
{
	float epsilon = 0.0001;
	vec3 xDir = vec3(epsilon, 0.0, 0.0);
	vec3 yDir = vec3(0.0, epsilon, 0.0);
	vec3 zDir = vec3(0.0, 0.0, epsilon);
	return normalize(vec3(DistanceEstimator(p+xDir)-DistanceEstimator(p-xDir),
		                  DistanceEstimator(p+yDir)-DistanceEstimator(p-yDir),
		                  DistanceEstimator(p+zDir)-DistanceEstimator(p-zDir)));
}

float castShadow(vec3 from)
{
	float mint = 0.0;
	float maxt = 128;
    float res = 1.0;

	float k = 16;

	vec3 rd = normalize(light_position - from);

    for( float t=mint; t < maxt; )
    {
        float h = DistanceEstimator(from + rd*t);
        if( h<0.001 )
            return 0.0;
        res = min( res, k*h/t );
        t += h;
    }

    return res;
}

vec3 trace(vec3 from, vec3 direction) 
{
	int MaximumRaySteps = 128;
	float MinimumDistance = 0.001;

	float totalDistance = 0.0;
	int steps;
	
	bool hit = false;
	vec3 p;
	float minDist = 100000;
	for (steps=0; steps < MaximumRaySteps; steps++) 
	{
		p = from + totalDistance * direction;
		float distance = DistanceEstimator(p);

		minDist = min(distance, minDist);

		totalDistance += distance;
		if (abs(distance) < MinimumDistance) 
		{
			hit = true;
			break;
		}
	}

	if (hit)
	{
		vec3 normal = normalAt(p);

		vec3 light_ray = normalize(light_position-p);
		float color = dot(normal, light_ray);

		vec3 halfwayDir = normalize(light_ray - direction);

		vec3 reflected = reflect(light_ray, normal);

		float specular = pow(max(dot(normal, halfwayDir), 0.0), 64);

		float shadow = castShadow(p+0.01*normal);
		return vec3(min(color+specular, 1.0)*shadow);
	}

	float glow = 0.0;//1.0/(1.0+10.0*minDist);

	return vec3(glow);
}

void main() 
{  
	ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.xy);
	vec2 screen_offset = vec2(render_dimension.x/2, render_dimension.y/2);
	
	vec3 pixel = vec3(0.0);
	
	vec3 camera_origin = vec3(0.0, 0.0, -render_dimension.x);
	vec3 screen_coord = vec3(pixel_coord-screen_offset, 0.0);
	
	vec3 ray = normalize(screen_coord - camera_origin);

	ray = rot_mat_camera*ray;

	pixel = vec3(trace(start_position, ray));

	imageStore(img_output, pixel_coord, vec4(pixel, 1.0));
}